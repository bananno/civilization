<%
  testing.lightAllTiles = true;
  testing.hideFogTiles = false;
  testing.showMapCellBorders = false;

  for (let r = 0; r < numRows; r++) {
    map[r] = [];
    for (let c = 0; c < numCols; c++) {
      map[r][c] = {
        myCity: false,
        rivalCity: false,
        cityId: null,
        myUnit: false,
        rivalUnit: false,
        moves: [],
        workTiles: [],
        buyTiles: [],
        lit: false || testing.lightAllTiles,
        discovered: false,
        edges: {
          dark: [],
          fog: [],
          coast: [],
          territory: [],
          road: [],
        },
        roads: [],
        player: null,
        owned: false,
      };
    }
  }

  let playerNums = {};
  players.forEach((player, i) => {
    playerNums[player._id] = i;
  });

  cities.forEach(city => {
    let [r, c] = city.location;

    map[r][c].cityId = city._id;

    if (isCurrentTurnPlayer(city.player)) {
      map[r][c].myCity = true;
    } else {
      map[r][c].rivalCity = true;
    }
  });

  const addRoad = (row, column, direction) => {
    if (row < 0 || row > numRows) {
      return;
    }
    if (column < 0) {
      column += numCols;
    } else if (column >= numCols) {
      column -= numCols;
    }
    map[row][column].roads.push(direction);
  };

  tiles.forEach(tile => {
    let [r, c] = tile.location;

    map[r] = map[r] || [];
    map[r][c].tile = tile;
    map[r][c].food = tile.production.food;
    map[r][c].gold = tile.production.gold;
    map[r][c].labor = tile.production.labor;
    map[r][c].discovered = tile.isDiscovered;

    if (tile.player) {
      map[r][c].player = playerNums[tile.player] + 1;
      if (isCurrentTurnPlayer(tile.player)) {
        map[r][c].owned = true;

        helpers.forEachAdjacentTile(numRows, numCols, tiles, r, c, (_, r1, c1) => {
          map[r1][c1].lit = true;
        });
      }
    }

    if (tile.road) {
      addRoad(r - 1, c, 'bottom');
      addRoad(r, c - 1, 'right');
      addRoad(r + 1, c, 'top');
      addRoad(r, c + 1, 'left');
    }
  });

  currentTurnCities.forEach(city => {
    const unemployedCitizens = help.numCityUnemployedCitizens(city);

    help.getCityWorkableTiles(city).forEach(tile => {
      let [r, c] = tile.location;
      let working = false;

      if ('' + tile.worked == '' + city._id) {
        working = true;
      } else if (unemployedCitizens <= 0) {
        working = 'disabled';
      }

      map[r][c].workTiles.push({
        cityId: city._id,
        path: '/workTile/' + city._id + '/' + tile._id,
        working: working,
      });

      help.forEachAdjacentTile(tile.location, outerTile => {
        if (outerTile.player) {
          return;
        }
        const [r1, c1] = outerTile.location;
        map[r1][c1].buyTiles.push({
          cityId: city._id,
          path: '/buyTile/' + city._id + '/' + outerTile._id,
          price: 10,
        });
      });
    });
  });

  let count1 = 0;

  currentTurnUnits.forEach(unit => {
    let [row, col] = unit.location;
    map[row][col].myUnit = true;
    map[row][col].unitId = unit._id;

    let litTiles = getVisibleTiles(row, col);

    litTiles.forEach(coords => {
      let [r, c] = coords;
      map[r][c].lit = true;
    });

    const inShiftedRow = row % 2 == 0;

    for (r = row - 2; r <= row + 2; r++) {
      if (r < 0) {
        continue;
      }
      if (r == game.mapSize[0]) {
        break;
      }
      for (cTemp = col - 2; cTemp <= col + 2; cTemp++) {
        let c = cTemp;

        if (c < 0) {
          c += game.mapSize[1];
        } else if (c >= game.mapSize[1]) {
          c -= game.mapSize[1];
        }

        if (unit.movesRemaining == 0) {
          continue;
        }

        let moveDirection = (() => {
          if (row == r) {
            if (cTemp == col - 1) {
              return 'left';
            }

            if (cTemp == col + 1) {
              return 'right';
            }

            return false;
          }

          let shift = inShiftedRow ? 1 : 0;

          if (r == row - 1) {
            if (c == col + shift - 1) {
              return 'up-left';
            }
            if (c == col + shift) {
              return 'up-right';
            }
          } else if (r == row + 1) {
            if (c == col + shift - 1) {
              return 'down-left';
            }
            if (c == col + shift) {
              return 'down-right';
            }
          }

          return false;
        })();

        if (!moveDirection) {
          continue;
        }

        if (map[r][c].tile.terrain.mountain) {
          continue;
        }

        if (unit.templateName == 'galley') {
          if (!map[r][c].tile.terrain.water && map[r][c].tile.improvement != 'city') {
            continue;
          }
        } else if (map[r][c].tile.terrain.water) {
          const boat = units.filter(unit => {
            return helpers.sameLocation(unit.location, [r, c]);
          })[0];
          if (!boat) {
            continue;
          }
        }

        map[r][c].moves.push({
          unitId: unit._id,
          path: '/moveUnit/' + unit._id + '/' + r + '/' + c,
          direction: moveDirection,
        });
      }
    }
  });

  rivalUnits.forEach(unit => {
    let [i, j] = unit.location;
    map[i][j].rivalUnit = true;
    map[i][j].unitId = unit._id;
  });
%>
