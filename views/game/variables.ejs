<%
  for (let r = 0; r < numRows; r++) {
    map[r] = [];
    for (let c = 0; c < numCols; c++) {
      map[r][c] = {
        myCity: false,
        rivalCity: false,
        cityId: null,
        myUnit: false,
        rivalUnit: false,
        moves: [],
        workTiles: [],
        lit: false,
        discovered: false,
        edges: [],
        roads: [],
        player: null,
        owned: false,
      };
    }
  }

  let playerNums = {};
  players.forEach((player, i) => {
    playerNums[player._id] = i;
  });

  cities.forEach(city => {
    let [r, c] = city.location;

    map[r][c].cityId = city._id;

    if (isCurrentTurnPlayer(city.player)) {
      map[r][c].myCity = true;
    } else {
      map[r][c].rivalCity = true;
    }
  });

  const addRoad = (row, column, direction) => {
    if (row < 0 || row > numRows) {
      return;
    }
    if (column < 0) {
      column += numCols;
    } else if (column >= numCols) {
      column -= numCols;
    }
    map[row][column].roads.push(direction);
  };

  tiles.forEach(tile => {
    let [r, c] = tile.location;

    map[r] = map[r] || [];
    map[r][c].tile = tile;
    map[r][c].food = tile.production.food;
    map[r][c].gold = tile.production.gold;
    map[r][c].labor = tile.production.labor;

    if (tile.player) {
      map[r][c].player = playerNums[tile.player] + 1;
      if (isCurrentTurnPlayer(tile.player)) {
        map[r][c].owned = true;

        for (let r1 = r - 1; r1 <= r + 1; r1++) {
          for (let cTemp = c - 1; cTemp <= c + 1; cTemp++) {
            let c1 = cTemp;
            if (c1 < 0) {
              c1 += numCols;
            } else if (c1 >= numCols) {
              c1 -= numCols;
            }
            if (map[r1] && map[r1][c1]) {
              map[r1][c1].lit = true;
            }
          }
        }
      }
    }

    if (tile.discovered.indexOf(turnPlayerId) >= 0) {
      map[r][c].discovered = true;
    }

    if (tile.road) {
      addRoad(r - 1, c, 'bottom');
      addRoad(r, c - 1, 'right');
      addRoad(r + 1, c, 'top');
      addRoad(r, c + 1, 'left');
    }
  });

  currentTurnCities.forEach(city => {
    let [row, col] = city.location;
    let alreadyCovered = {};

    let cityTilesWorked = tiles.filter(tile => {
      return '' + tile.worked == '' + city._id;
    });

    let atMaxWork = cityTilesWorked.length >= city.population + 1;

    const addWorkingTile = (r, c1) => {
      if (Math.abs(row - r) > 3 || Math.abs(col - c1) > 3) {
        return;
      }

      if (r < 0 || r >= game.mapSize[0]) {
        return;
      }

      let c = c1;

      if (c < 0) {
        c += game.mapSize[1];
      } else if (c >= game.mapSize[1]) {
        c -= game.mapSize[1];
      }

      if (alreadyCovered[r + ',' + c]) {
        return;
      }

      alreadyCovered[r + ',' + c] = true;

      if (!map[r][c].owned) {
        return;
      }

      let workable = true;

      if (map[r][c].cityId) {
        workable = false;
      }

      let tileOutput = 0;

      ['gold', 'food', 'labor', 'culture', 'science'].forEach(prod => {
        tileOutput +=  map[r][c].tile.production[prod];
      });

      if (tileOutput == 0) {
        workable = false;
      }

      if (workable) {
        let tile = map[r][c].tile;
        let working = false;

        if ('' + tile.worked == '' + city._id) {
          working = true;
        } else if (atMaxWork) {
          working = 'disabled';
        }

        map[r][c].workTiles.push({
          cityId: city._id,
          path: '/workTile/' + city._id + '/' + tile._id,
          working: working,
        });
      }

      addWorkingTile(r - 1, c1);
      addWorkingTile(r + 1, c1);
      addWorkingTile(r, c1 - 1);
      addWorkingTile(r, c1 + 1);
    };

    addWorkingTile(row, col);
  });

  let count1 = 0;

  currentTurnUnits.forEach(unit => {
    let [row, col] = unit.location;
    map[row][col].myUnit = true;
    map[row][col].unitId = unit._id;

    let litTiles = getVisibleTiles(row, col);

    litTiles.forEach(coords => {
      let [r, c] = coords;
      map[r][c].lit = true;
    });

    for (r = row - 2; r <= row + 2; r++) {
      if (r < 0) {
        continue;
      }
      if (r == game.mapSize[0]) {
        break;
      }
      for (cTemp = col - 2; cTemp <= col + 2; cTemp++) {
        let c = cTemp;

        if (c < 0) {
          c += game.mapSize[1];
        } else if (c >= game.mapSize[1]) {
          c -= game.mapSize[1];
        }

        if (unit.movesRemaining == 0) {
          continue;
        }

        let moveDirection = (() => {
          if (col == c) {
            if (r == row + 1) {
              return 'down';
            }
            if (r == row - 1) {
              return 'up';
            }
            return false;
          }

          if (row != r) {
            return false;
          }

          if (c == col -1 || (c == game.mapSize[1] - 1 && col == 0)) {
            return 'left';
          }

          if (c == col + 1 || (col == game.mapSize[1] - 1 && c == 0)) {
            return 'right';
          }

          return false;
        })();

        if (!moveDirection) {
          continue;
        }

        if (map[r][c].tile.terrain.mountain || map[r][c].tile.terrain.water) {
          continue;
        }

        map[r][c].moves.push({
          unitId: unit._id,
          path: '/moveUnit/' + unit._id + '/' + r + '/' + c,
          direction: moveDirection,
        });
      }
    }
  });

  rivalUnits.forEach(unit => {
    let [i, j] = unit.location;
    map[i][j].rivalUnit = true;
    map[i][j].unitId = unit._id;
  });
%>
