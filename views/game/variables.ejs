<%
  testing.lightAllTiles = false;
  testing.hideFogTiles = false;
  testing.showMapCellBorders = false;

  for (let r = 0; r < numRows; r++) {
    map[r] = [];
    for (let c = 0; c < numCols; c++) {
      map[r][c] = {
        myCity: false,
        rivalCity: false,
        cityId: null,
        myUnit: false,
        rivalUnit: false,
        moves: [],
        workTiles: [],
        lit: false || testing.lightAllTiles,
        discovered: false,
        edges: {
          dark: [],
          fog: [],
          coast: [],
          road: [],
        },
        roads: [],
        player: null,
        owned: false,
      };
    }
  }

  let playerNums = {};
  players.forEach((player, i) => {
    playerNums[player._id] = i;
  });

  cities.forEach(city => {
    let [r, c] = city.location;

    map[r][c].cityId = city._id;

    if (isCurrentTurnPlayer(city.player)) {
      map[r][c].myCity = true;
    } else {
      map[r][c].rivalCity = true;
    }
  });

  const addRoad = (row, column, direction) => {
    if (row < 0 || row > numRows) {
      return;
    }
    if (column < 0) {
      column += numCols;
    } else if (column >= numCols) {
      column -= numCols;
    }
    map[row][column].roads.push(direction);
  };

  tiles.forEach(tile => {
    let [r, c] = tile.location;

    map[r] = map[r] || [];
    map[r][c].tile = tile;
    map[r][c].food = tile.production.food;
    map[r][c].gold = tile.production.gold;
    map[r][c].labor = tile.production.labor;

    if (tile.player) {
      map[r][c].player = playerNums[tile.player] + 1;
      if (isCurrentTurnPlayer(tile.player)) {
        map[r][c].owned = true;

        helpers.forEachAdjacentTile(numRows, numCols, tiles, r, c, (_, r1, c1) => {
          map[r1][c1].lit = true;
        });
      }
    }

    if (tile.discovered.indexOf(turnPlayerId) >= 0) {
      map[r][c].discovered = true;
    }

    if (tile.road) {
      addRoad(r - 1, c, 'bottom');
      addRoad(r, c - 1, 'right');
      addRoad(r + 1, c, 'top');
      addRoad(r, c + 1, 'left');
    }
  });

  currentTurnCities.forEach(city => {
    let [row, col] = city.location;
    let alreadyCovered = {};

    let cityTilesWorked = tiles.filter(tile => {
      return '' + tile.worked == '' + city._id;
    });

    let atMaxWork = cityTilesWorked.length >= city.population + 1;

    const addWorkingTile = (r, c1) => {
      if (Math.abs(row - r) > 3 || Math.abs(col - c1) > 3) {
        return;
      }

      if (r < 0 || r >= game.mapSize[0]) {
        return;
      }

      let c = c1;

      if (c < 0) {
        c += game.mapSize[1];
      } else if (c >= game.mapSize[1]) {
        c -= game.mapSize[1];
      }

      if (alreadyCovered[r + ',' + c]) {
        return;
      }

      alreadyCovered[r + ',' + c] = true;

      if (!map[r][c].owned) {
        return;
      }

      let workable = true;

      if (map[r][c].cityId) {
        workable = false;
      }

      let tileOutput = 0;

      ['gold', 'food', 'labor', 'culture', 'science'].forEach(prod => {
        tileOutput +=  map[r][c].tile.production[prod];
      });

      if (tileOutput == 0) {
        workable = false;
      }

      if (workable) {
        let tile = map[r][c].tile;
        let working = false;

        if ('' + tile.worked == '' + city._id) {
          working = true;
        } else if (atMaxWork) {
          working = 'disabled';
        }

        map[r][c].workTiles.push({
          cityId: city._id,
          path: '/workTile/' + city._id + '/' + tile._id,
          working: working,
        });
      }

      addWorkingTile(r - 1, c1);
      addWorkingTile(r + 1, c1);
      addWorkingTile(r, c1 - 1);
      addWorkingTile(r, c1 + 1);
    };

    addWorkingTile(row, col);
  });

  let count1 = 0;

  currentTurnUnits.forEach(unit => {
    let [row, col] = unit.location;
    map[row][col].myUnit = true;
    map[row][col].unitId = unit._id;

    let litTiles = getVisibleTiles(row, col);

    litTiles.forEach(coords => {
      let [r, c] = coords;
      map[r][c].lit = true;
    });

    const inShiftedRow = row % 2 == 0;

    for (r = row - 2; r <= row + 2; r++) {
      if (r < 0) {
        continue;
      }
      if (r == game.mapSize[0]) {
        break;
      }
      for (cTemp = col - 2; cTemp <= col + 2; cTemp++) {
        let c = cTemp;

        if (c < 0) {
          c += game.mapSize[1];
        } else if (c >= game.mapSize[1]) {
          c -= game.mapSize[1];
        }

        if (unit.movesRemaining == 0) {
          continue;
        }

        let moveDirection = (() => {
          if (row == r) {
            if (cTemp == col - 1) {
              return 'left';
            }

            if (cTemp == col + 1) {
              return 'right';
            }

            return false;
          }

          let shift = inShiftedRow ? 1 : 0;

          if (r == row - 1) {
            if (c == col + shift - 1) {
              return 'up-left';
            }
            if (c == col + shift) {
              return 'up-right';
            }
          } else if (r == row + 1) {
            if (c == col + shift - 1) {
              return 'down-left';
            }
            if (c == col + shift) {
              return 'down-right';
            }
          }

          return false;
        })();

        if (!moveDirection) {
          continue;
        }

        if (map[r][c].tile.terrain.mountain) {
          continue;
        }

        if (unit.templateName == 'galley') {
          if (!map[r][c].tile.terrain.water && map[r][c].tile.improvement != 'city') {
            continue;
          }
        } else if (map[r][c].tile.terrain.water) {
          const boat = units.filter(unit => {
            return helpers.sameLocation(unit.location, [r, c]);
          })[0];
          if (!boat) {
            continue;
          }
        }

        map[r][c].moves.push({
          unitId: unit._id,
          path: '/moveUnit/' + unit._id + '/' + r + '/' + c,
          direction: moveDirection,
        });
      }
    }
  });

  rivalUnits.forEach(unit => {
    let [i, j] = unit.location;
    map[i][j].rivalUnit = true;
    map[i][j].unitId = unit._id;
  });
%>
