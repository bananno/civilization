<%
    for (let i = 0; i < game.mapSize[0]; i++) {
        map[i] = [];
        for (let j = 0; j < game.mapSize[1]; j++) {
            map[i][j] = {
                myCity: false,
                rivalCity: false,
                cityId: null,
                myUnit: false,
                rivalUnit: false,
                moves: [],
                workTiles: [],
                lit: false,
                discovered: false,
                player: null,
                owned: false,
            };
        }
    }

    let playerNums = {};
    players.forEach((player, i) => {
        playerNums[player._id] = i;
    });

    cities.forEach(city => {
        let row = city.location[0];
        let col = city.location[1];

        map[row][col].cityId = city._id;

        if (city.player == currentTurnPlayerId) {
            map[row][col].myCity = true;
        } else {
            map[row][col].rivalCity = true;
        }
    });

    tiles.forEach(tile => {
        map[tile.row] = map[tile.row] || [];
        map[tile.row][tile.column].tile = tile;
        map[tile.row][tile.column].food = tile.food;
        map[tile.row][tile.column].gold = tile.gold;

        if (tile.player) {
            map[tile.row][tile.column].player = playerNums[tile.player] + 1;
            if (tile.player == currentTurnPlayerId) {
                map[tile.row][tile.column].owned = true;

                for (let i = tile.row - 1; i <= tile.row + 1; i++) {
                    for (let j1 = tile.column - 1; j1 <= tile.column + 1; j1++) {
                        let j = j1;
                        if (j < 0) {
                            j += game.mapSize[1];
                        } else if (j >= game.mapSize[1]) {
                            j -= game.mapSize[1];
                        }
                        if (map[i] && map[i][j]) {
                            map[i][j].lit = true;
                        }
                    }
                }
            }
        }

        if (tile.improvement == 'farm') {
            map[tile.row][tile.column].food += 1;
        }

        if (tile.discovered.indexOf(currentTurnPlayerId) >= 0) {
            map[tile.row][tile.column].discovered = true;
        }
    });

    currentTurnCities.forEach(city => {
        let [row, col] = city.location;
        let alreadyCovered = {};

        let cityTilesWorked = tiles.filter(tile => {
            return '' + tile.worked == '' + city._id;
        });

        let atMaxWork = cityTilesWorked.length >= city.population;

        const addWorkingTile = (r, c1) => {
            if (Math.abs(row - r) > 3 || Math.abs(col - c1) > 3) {
                return;
            }

            if (r < 0 || r >= game.mapSize[0]) {
                return;
            }

            let c = c1;

            if (c < 0) {
                c += game.mapSize[1];
            } else if (c >= game.mapSize[1]) {
                c -= game.mapSize[1];
            }

            if (alreadyCovered[r + ',' + c]) {
                return;
            }

            alreadyCovered[r + ',' + c] = true;

            if (!map[r][c].owned) {
                return;
            }

            let workable = true;

            if (map[r][c].cityId) {
                workable = false;
            }

            if (workable) {
                let tile = map[r][c].tile;
                let working = false;

                if ('' + tile.worked == '' + city._id) {
                    working = true;
                } else if (atMaxWork) {
                    working = 'disabled';
                }

                map[r][c].workTiles.push({
                    cityId: city._id,
                    path: '/workTile/' + city._id + '/' + tile._id,
                    working: working,
                });
            }

            addWorkingTile(r - 1, c1);
            addWorkingTile(r + 1, c1);
            addWorkingTile(r, c1 - 1);
            addWorkingTile(r, c1 + 1);
        };

        addWorkingTile(row, col);
    });

    currentTurnUnits.forEach(unit => {
        let [row, col] = unit.location;
        map[row][col].myUnit = true;
        map[row][col].unitId = unit._id;

        for (r = row - 2; r <= row + 2; r++) {
            if (r < 0) {
                continue;
            }
            if (r == game.mapSize[0]) {
                break;
            }
            for (cTemp = col - 2; cTemp <= col + 2; cTemp++) {
                let c = cTemp;

                if (c < 0) {
                    c += game.mapSize[1];
                } else if (c >= game.mapSize[1]) {
                    c -= game.mapSize[1];
                }

                map[r][c].lit = true;

                if (unit.movesRemaining == 0) {
                    continue;
                }

                let moveDirection = (() => {
                    if (col == c) {
                        if (r == row + 1) {
                            return 'down';
                        }
                        if (r == row - 1) {
                            return 'up';
                        }
                        return false;
                    }

                    if (row != r) {
                        return false;
                    }

                    if (c == col -1 || (c == game.mapSize[1] - 1 && col == 0)) {
                        return 'left';
                    }

                    if (c == col + 1 || (col == game.mapSize[1] - 1 && c == 0)) {
                        return 'right';
                    }

                    return false;
                })();

                if (moveDirection) {
                    map[r][c].moves.push({
                        unitId: unit._id,
                        path: '/moveUnit/' + unit._id + '/' + r + '/' + c,
                        direction: moveDirection,
                    });
                }
            }
        }
    });

    rivalUnits.forEach(unit => {
        let [i, j] = unit.location;
        map[i][j].rivalUnit = true;
        map[i][j].unitId = unit._id;
    });
%>
